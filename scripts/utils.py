import os,sys,shutil, json, random, multiprocessing, re
import pandas as pd
import numpy as np
from functools import partial
from PIL import Image
from pathlib import Path


sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from scripts.params import *
from scripts.matrix_function import *
from scripts.reax_ff_data import bo

with open('scripts/test_indices.json', 'r') as f:
    test_indices = json.load(f)

qm7_val = test_indices['qm7_val']
qm8_val = test_indices['qm8_val']
qm9_val = test_indices['qm9_val']
#qm9_2_val = test_indices['qm9_2_val']
#qm9_3_val = test_indices['qm9_3_val']
#qm9_4_val = test_indices['qm9_4_val']
#qm9_6_val = test_indices['qm9_6_val']
#qm9_32_val = test_indices['qm9_32_val']

qm9_train = test_indices['qm9_train']
qm9_2_train = test_indices['qm9_2_train']
qm9_3_train = test_indices['qm9_3_train']
qm9_4_train = test_indices['qm9_4_train']
qm9_6_train = test_indices['qm9_6_train']

def get_list_of_files():
    '''Get the list of all .xyz file available, if directory is empty then exctract information from .tar file'''
    try:
        files = os.listdir(f'{PATH}/data')
    except FileNotFoundError:
        os.system('mkdir data')
        os.system(f'tar -xvf dsgdb9nsd.xyz.tar.bz2 -C {PATH}/data')
        files = os.listdir(f'{PATH}/data')

    return files

r_range, g_range, b_range = (0,1),(0,1),(0,1)
def scale_rgb_values(r, g, b):
    global r_range, g_range, b_range

    r = (255 * (r - r_range[0]) / (r_range[1] - r_range[0])).astype(int)
    g = (255 * (g - g_range[0]) / (g_range[1] - g_range[0])).astype(int)
    b = (255 * (b - b_range[0]) / (b_range[1] - b_range[0])).astype(int)
    return r, g, b

def calibration(ds, STEP, bo):

    '''A function that checks whether the matrices generated 
    on the entered settings contain values in the range 0-255

    '''
    
    if 'qm7' == DB.split('_')[0]: ds = pd.read_csv(f'{PATH}/qm7_vanilla.csv')
    if 'qm8' == DB.split('_')[0]: ds = pd.read_csv(f'{PATH}/qm8_vanilla.csv')
    if 'qm9' == DB.split('_')[0]: ds = pd.read_csv(f'{PATH}/qm9_vanilla.csv')
    global r_range, g_range, b_range
    data = []
    start = random.randint(0,5) #to avoid too long execution
    for compound in range(start, len(ds), STEP): #step != 1 to avoid too long execution
        data.append(making_rgb_numerically(compound, bo, ds, scaling=False))
        print(f'\rCalibration: {100*compound/len(ds):.2f}%', end='')

    max_values = []
    min_values = []

    for matrices_group in zip(*data):
      max_group = np.max([np.max(matrix) for matrix in matrices_group])
      min_group = np.min([np.min(matrix) for matrix in matrices_group])
      max_values.append(max_group)
      min_values.append(min_group)

    print(f"\nr_range= {min_values[0]:.2f}, {max_values[0]:.2f}")
    print(f"g_range= {min_values[1]:.2f}, {max_values[1]:.2f}")
    print(f"b_range= {min_values[2]:.2f}, {max_values[2]:.2f}")
    return (min_values[0],max_values[0]),(min_values[1],max_values[1]),(min_values[2],max_values[2])

def making_rgb_numerically(row, bo, ds, scaling=SCALING, verbose = False, image_type = TYPE_OF_IMAGE, RANDOM_OR=RANDOM_OR, MARGIN=MARGIN):
    '''function that, based on a single row in the database, creates three 
    MATRIX_SIZExMATRIX_SIZE matrices that contain numerical data generated by 
    various functions contained in the file matrix_function.py'''

    cords = eval(ds.cords.iloc[row])
    n_atoms = ds.n_atoms.iloc[row]
    atom_types = eval(ds.atom_type.iloc[row])
    
    if image_type == 'A':
        r = distance(cords, n_atoms)
        r += ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    
        #b = (atomic_charge(atom_types, n_atoms))
        b = (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'B':
        r = distance(cords, n_atoms)
        r += ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = True)
    
        #b = (atomic_charge(atom_types, n_atoms))
        b = (bond_order(distance(cords, n_atoms), atom_types, bo))


    elif image_type == 'C':
        r = distance(cords, n_atoms)
        #r += ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    
        #b = (atomic_charge(atom_types, n_atoms))
        b = (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'D':
        r = distance(cords, n_atoms)
        #r += ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    
        b = (atomic_charge(atom_types, n_atoms))
        b += (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'E':
        #r = distance(cords, n_atoms)
        r = ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = True)
    
        b = (atomic_charge(atom_types, n_atoms))
        #b += (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'F':
        r = distance(cords, n_atoms)
        r += ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = True)
    
        b = (atomic_charge(atom_types, n_atoms))
        #b += (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'G':
        r = distance(cords, n_atoms)
        #r += ionization(atom_types, n_atoms)

        g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g += coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    
        b = (atomic_charge(atom_types, n_atoms))
        b += (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'H':
        r = distance(cords, n_atoms)
        r += ionization(atom_types, n_atoms)

        g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g += coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    
        b = (atomic_charge(atom_types, n_atoms))
        b += (bond_order(distance(cords, n_atoms), atom_types, bo))

    if scaling:
        r,g,b = scale_rgb_values(r,g,b) 


    #pasting the matrix into larger black matrix in random way		
    if RANDOM_OR == True: 
        init_cords = (random.randint(0,MATRIX_SIZE-n_atoms), random.randint(0,MATRIX_SIZE-n_atoms)) 
    else: 
        init_cords = (0,0)

    if MARGIN == 'black':
        value_r, value_g, value_b=0,0,0
    elif MARGIN=='white':
        value_r, value_g, value_b=255,255,255 #calibration does not work well
    elif MARGIN=='avg':
        value_r, value_g, value_b = np.mean(r), np.mean(g), np.mean(b)
    
    if MATRIX_SIZE != 0:
        final_r = np.full((MATRIX_SIZE, MATRIX_SIZE), value_r)
        final_g = np.full((MATRIX_SIZE, MATRIX_SIZE), value_g)
        final_b = np.full((MATRIX_SIZE, MATRIX_SIZE), value_b)

        final_r[init_cords[0]:init_cords[0] + n_atoms, init_cords[1]:init_cords[1] + n_atoms] = r
        final_g[init_cords[0]:init_cords[0] + n_atoms, init_cords[1]:init_cords[1] + n_atoms] = g
        final_b[init_cords[0]:init_cords[0] + n_atoms, init_cords[1]:init_cords[1] + n_atoms] = b

        return final_r, final_g, final_b
    return r,g,b

def making_rgb(mat, id, label):
  ''' Function that takes the result of the making_rgb_numerically function and transforms the set of three matrices into a finished png image'''
  combined = np.transpose(np.array((mat[0],mat[1],mat[2])),(1,2,0))

  img = np.array(combined, dtype=np.uint8)

  pImg = Image.fromarray(img, mode='RGB')

  pImg.save(f"{PATH}/{label}/{id}.png")

def process_image(chem, bo, ds, split):

    #test set
    if DB == 'qm7_demo':
        test_set = qm7_val
    elif DB == 'qm8_demo':
        test_set = qm8_val
    elif DB.split('_')[0] == 'qm9':
        test_set = qm9_val
    else:
        test_set = []

    #train set
    if DB == 'qm9_2':
        train_set = qm9_2_train
    elif DB == 'qm9_3':
        train_set = qm9_3_train
    elif DB == 'qm9_4':
        train_set = qm9_4_train
    elif DB == 'qm9_6':
        train_set = qm9_6_train
    else:
        train_set = qm9_train

    if int(ds.ID.iloc[chem].split('_')[1]) in test_set:
        making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TEST_DIR_NAME)
        print(f"\r{chem} goes to test set", end='')
    elif int(ds.ID.iloc[chem].split('_')[1]) in train_set:
        making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TRAIN_DIR_NAME)

def creating_images(start, end, bo, ds, STEP, split=0.1):
    print(f'Creating {end-start+1} images for training model')
    print(f'Rearranging train and test files')
    
    try:
        shutil.rmtree(f'{PATH}/{TRAIN_DIR_NAME}')
        os.makedirs(f'{PATH}/{TRAIN_DIR_NAME}', exist_ok=True)
    except FileNotFoundError:
        os.makedirs(f'{PATH}/{TRAIN_DIR_NAME}', exist_ok=True)

    try:
        shutil.rmtree(f'{PATH}/{TEST_DIR_NAME}')
        os.makedirs(f'{PATH}/{TEST_DIR_NAME}', exist_ok=True)
    except FileNotFoundError:
        os.makedirs(f'{PATH}/{TEST_DIR_NAME}', exist_ok=True)
    
    if SCALING==True:
        global r_range, g_range, b_range
        print(f'Calibration for each spectra (based on {len(ds)/STEP/len(ds)*100:.2f}% of data):')
        r_range, g_range, b_range = calibration(ds,STEP,bo)
    
    print(f'Creating images, this process may take a lot of time')

    if MULTIPROCESS:
        process_image_partial = partial(process_image, bo=bo, ds=ds, split=split)

        #multiprocessing
        print(f'Running with multiprocessing using {NUM_PROC} processes')
        with multiprocessing.Pool(processes=NUM_PROC) as pool:
            pool.map(process_image_partial, range(start, end+1))
    else:
        #singleprocessing
        print('Running without multiprocessing')
        for chem in range(start, end+1):
            print(f"\r{chem}/{end+1}",end='')
            process_image(chem, bo=bo, ds=ds, split=split)
    print(f'Creating images have been finished. There are {len(os.listdir(f'{PATH}/{TRAIN_DIR_NAME}'))} files in {TRAIN_DIR_NAME} directory and {len(os.listdir(f'{PATH}/{TEST_DIR_NAME}'))} in {TEST_DIR_NAME} directory.')

def modify_params(changes):
    '''Function which modify params in scripts/params.py file
    Changes is a directory with new values of param e.g. {'CYCLE':4}'''
    with open('scripts/params.py', 'r') as file:
        content = file.read()

    for param, value in changes.items():
        if isinstance(value, str):
            value = f"'{value}'"
        content = re.sub(f'{param} = .*', f'{param} = {value}', content)


    with open('scripts/params.py', 'w') as file:
        file.write(content)