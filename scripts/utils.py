import os
import pandas as pd
import numpy as np
from .matrix_function import *
from PIL import Image
import random
from pathlib import Path
from .params import *
from reax_ff_data import bo


#does not work well, in effect making_df does not work well either
try:
    files = os.listdir(f'{PATH}/data')
except FileNotFoundError:
    os.system('mkdir data')
    os.system(f'tar -xvf dsgdb9nsd.xyz.tar.bz2 -C {PATH}/data')
    files = os.listdir(f'{PATH}/data')

def extracting(f, shuffle = SHUFFLE):
    ''' Extracts information from .xyz file into single dataframe row'''
    with open(f, 'r') as file:
        lines = file.readlines()

    df_record = {'n_atoms': int(lines[0].strip()), 'atom_type': [], 'cords': [], 'mulliken': []}

    properties = lines[1].split("\t")
    
    labels = ['ID','A','B','C','Dipole moment','Isotropic Polarizability', 'Energy of HOMO',
              'Energy of LUMO','HOMO-LUMO Gap','Electronic spatial extent','Zero point vibrational energy',
              'Internal energy at 0K','Internal energy at 298K','Enthalphy at 298K',
              'Free energy at 298K','Heat capacity at 298K']
    
    df_record.update(zip(labels, properties))

    #coordinates 
    for atom in range(df_record['n_atoms']):
        atom_record = lines[2+atom].replace('\n','').split('\t')
        df_record['atom_type'].append(atom_record[0])
        df_record['cords'].append(atom_record[1:-1])
        df_record['mulliken'].append(atom_record[-1])

    '''If shuffle = True then the order of atoms in the molecule is randomized'''
    if shuffle == True:
        combined = list(zip(atom_type, cords, mulliken))
        random.shuffle(combined)
        atom_type, cords, mulliken = zip(*combined)


    df_record['atom_type'] = atom_type
    df_record['cords'] = cords
    df_record['mulliken'] = mulliken


    return df_record

def making_df(l=len(files), cycle=CYCLE):
    ''' Function using the extraction function to create an entire database from a list of .xyz file names'''
    df = []
    os.chdir(f'{PATH}/data')

    random_file = random.sample(files, l)

    for idx, file in enumerate(random_file):
        if idx % 1000 == 0:
            print(round(idx / l * 100, 2))
        df.extend(extracting(file) for _ in range(cycle))
        
    ds = pd.DataFrame(data = df)
    
    print(f'Database of lenght {len(ds)} was successfully created based on {len(files)} files')

    ds.to_csv(os.path.join(PATH, f"{DB}.csv"))
    return ds


def scale_rgb_values(r, g, b, r_range=(0, 17.422), g_range=(0, 44.602), b_range=(0, 9)):
    r = (255 * (r - r_range[0]) / (r_range[1] - r_range[0])).astype(int)
    g = (255 * (g - g_range[0]) / (g_range[1] - g_range[0])).astype(int)
    b = (255 * (b - b_range[0]) / (b_range[1] - b_range[0])).astype(int)

    return r, g, b

def making_rgb_numerically(row, bo, ds, scaling=True, verbose = False):
    '''function that, based on a single row in the database, creates three 
    MATRIX_SIZExMATRIX_SIZE matrices that contain numerical data generated by 
    various functions contained in the file matrix_function.py'''

    cords = eval(ds.cords.iloc[row])
    n_atoms = ds.n_atoms.iloc[row]
    atom_types = eval(ds.atom_type.iloc[row])

    r = distance(cords, n_atoms)
    #r += ionization(atom_types, n_atoms)
    #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
    g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    #b = (atomic_charge(atom_types, n_atoms))
    b = (bond_order(distance(cords, n_atoms), atom_types, bo))
    return scale_rgb_values(r,g,b) if scaling ==True else r,g,b

def calibration(ds, d, bo):

    '''A function that checks whether the matrices generated 
    on the entered settings contain values in the range 0-255
    '''
    data = []
    c = []
    start = random.randint(0,5) #to avoid too long execution
    for compound in range(start, len(ds), int(len(ds)/d)): #step != 1 to avoid too long execution

        try:
            data.append(making_rgb_numerically(compound, bo))
        except ValueError:
            print(ds.ID.iloc[compound])
        c.append(ds.ID.iloc[compound])

        if compound%10 == 0:
            print(compound)

    max_values = []
    min_values = []

    for matrices_group in zip(*data):
      max_group = np.max([np.max(matrix) for matrix in matrices_group])
      min_group = np.min([np.min(matrix) for matrix in matrices_group])
      max_values.append(max_group)
      min_values.append(min_group)

    print("r_range=", (min_values[0], max_values[1]))
    print("g_range=", (min_values[1], max_values[1]))
    print("b_range=", (min_values[2], max_values[2]))

def making_rgb(mat, id, label):
  ''' Function that takes the result of the making_rgb_numerically function and transforms the set of three matrices into a finished png image'''
  
  combined = np.transpose(np.array((mat[0][0],mat[0][1],mat[0][2])),(1,2,0))

  img = np.array(combined, dtype=np.uint8)

  pImg = Image.fromarray(img, mode='RGB')

  pImg.save(f"{PATH}/{label}/{id}.png")

def creating_images(start, end, bo, ds, split=0.1, step=1):
    ''' A function that is an automation of the making_rgb function '''
    os.makedirs(f'{PATH}/{TRAIN_DIR_NAME}', exist_ok=True)
    os.makedirs(f'{PATH}/{TEST_DIR_NAME}', exist_ok = True)

    for chem in range(start, end+1, step):
        if random.randint(1,int(1/split)) == int(1/split):
            making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label = TEST_DIR_NAME)
            print(f"{chem} goes to test set")
        else:

            making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TRAIN_DIR_NAME)

import matplotlib.pyplot as plt
def p(num_epochs, losses, accuracies):
  ''' Function to plot change in loss and accuracy values while training the model '''
  x = range(num_epochs)[2:]

  fig, ax1 = plt.subplots()

  losses = [1/x for x in losses]
  color = 'tab:blue'
  ax1.set_xlabel('Epochs')
  ax1.set_ylabel('loss', color=color)
  ax1.plot(x, losses[2:], color=color)
  ax1.tick_params(axis='y', labelcolor=color)

  ax2 = ax1.twinx()  
  color = 'tab:red'
  ax2.set_ylabel('accuracy', color=color)
  ax2.plot(x, accuracies[2:], color=color)
  ax2.tick_params(axis='y', labelcolor=color)

  plt.title('Loss and accuracy[meV] value')
  plt.show()
    
if __name__ == '__main__':

    import time
    import argparse
    
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('--makedf', dest='making_dataframe', action='store_true', help='Creating dataframe from scratch ~15 minutes')
    parser.add_argument('--cal', dest='calibration', action='store_true', help='Calibrate numerical values of RGB representation')
    parser.add_argument('--create','-c', dest='create_files', action='store_true', help='Create images from scratch ~20 minutes')
    parser.add_argument('--start', dest='start', type = int, default = 0, help='Number of molecules to take in consideration')
    parser.add_argument('--end', dest='end', type = int, default = 133885, help='Number of molecules to take in consideration')
    parser.add_argument('--n', dest='quantity', type = int, default = 133885, help='Number of molecules to take in consideration')

    args = parser.parse_args()

    start = args.start
    end = args.end
    d = args.quantity

    if args.making_dataframe:
        s = time.time()
        ds = making_df(d)
        ds[PREDICTED_VALUE] *= 27211
        
        e = time.time()
        print(f'Creating dataframe took {round(e-s,2)} seconds')
    else:
        ds = pd.read_csv(f'{DB}.csv')

    if args.calibration:
        s = time.time()
        with open('reaxff_cohnsli.lib','r') as f:
            lines = f.readlines()
            lines = [x.strip().split() for x in lines]

        calibration(ds, d, bo)
        e = time.time()
        print(f"Calibration took {round(e-s,2)} seconds")

    if args.create_files:
        s = time.time()
        creating_images(start, end, bo, 0.1, 1)
        e = time.time()
        print(f"Creation of images took {round(e-s,2)} seconds")

