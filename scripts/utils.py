import os,sys,shutil, json
import pandas as pd
import numpy as np
import multiprocessing
from functools import partial
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from scripts.matrix_function import *
from PIL import Image
import random
from pathlib import Path
from scripts.params import *
from scripts.reax_ff_data import bo

with open('scripts/test_indices.json', 'r') as f:
    test_indices = json.load(f)

qm7_val = test_indices['qm7_val']
qm8_val = test_indices['qm8_val']
qm9_val = test_indices['qm9_val']
qm9_2_val = test_indices['qm9_2_val']
qm9_3_val = test_indices['qm9_3_val']
qm9_4_val = test_indices['qm9_4_val']
qm9_6_val = test_indices['qm9_6_val']

def get_list_of_files():
    '''Get the list of all .xyz file available, if directory is empty then exctract information from .tar file'''
    try:
        files = os.listdir(f'{PATH}/data')
    except FileNotFoundError:
        os.system('mkdir data')
        os.system(f'tar -xvf dsgdb9nsd.xyz.tar.bz2 -C {PATH}/data')
        files = os.listdir(f'{PATH}/data')
    
    return files

r_range, g_range, b_range = (0,1),(0,1),(0,1)
def scale_rgb_values(r, g, b):
    global r_range, g_range, b_range
    r = (255 * (r - r_range[0]) / (r_range[1] - r_range[0])).astype(int)
    g = (255 * (g - g_range[0]) / (g_range[1] - g_range[0])).astype(int)
    b = (255 * (b - b_range[0]) / (b_range[1] - b_range[0])).astype(int)

    return r, g, b

def calibration(ds, d, bo):

    '''A function that checks whether the matrices generated 
    on the entered settings contain values in the range 0-255

    '''

    if 'qm7' == DB.split('_')[0]: ds = pd.read_csv('qm7_vanilla.csv')
    if 'qm8' == DB.split('_')[0]: ds = pd.read_csv('qm8_vanilla.csv')
    if 'qm9' == DB.split('_')[0]: ds = pd.read_csv('qm9_vanilla.csv')
    global r_range, g_range, b_range
    data = []
    start = random.randint(0,5) #to avoid too long execution
    for compound in range(start, len(ds), d): #step != 1 to avoid too long execution
        data.append(making_rgb_numerically(compound, bo, ds, scaling=False))
        print(f'\rCalibration: {100*compound/len(ds):.2f}%', end='')

    max_values = []
    min_values = []

    for matrices_group in zip(*data):
      max_group = np.max([np.max(matrix) for matrix in matrices_group])
      min_group = np.min([np.min(matrix) for matrix in matrices_group])
      max_values.append(max_group)
      min_values.append(min_group)

    print(f"\nr_range= {min_values[0]:.2f}, {max_values[0]:.2f}")
    print(f"g_range= {min_values[1]:.2f}, {max_values[1]:.2f}")
    print(f"b_range= {min_values[2]:.2f}, {max_values[2]:.2f}")
    return (min_values[0],max_values[0]),(min_values[1],max_values[1]),(min_values[2],max_values[2])

def making_rgb_numerically(row, bo, ds, scaling=SCALING, verbose = False, image_type = TYPE_OF_IMAGE, RANDOM_OR=RANDOM_OR, MARGIN=MARGIN):
    '''function that, based on a single row in the database, creates three 
    MATRIX_SIZExMATRIX_SIZE matrices that contain numerical data generated by 
    various functions contained in the file matrix_function.py'''

    cords = eval(ds.cords.iloc[row])
    n_atoms = ds.n_atoms.iloc[row]
    atom_types = eval(ds.atom_type.iloc[row])
    
    if image_type == 'A':
        r = distance(cords, n_atoms)
        r = ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    
        #b = (atomic_charge(atom_types, n_atoms))
        b = (bond_order(distance(cords, n_atoms), atom_types, bo))

    elif image_type == 'B':
        r = distance(cords, n_atoms)
        r += ionization(atom_types, n_atoms)

        #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
        g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = True)
    
        b = (atomic_charge(atom_types, n_atoms))
        b = (bond_order(distance(cords, n_atoms), atom_types, bo))

    if scaling:
        r,g,b = scale_rgb_values(r,g,b) 


    #pasting the matrix into larger black matrix in random way		
    if RANDOM_OR == True: 
        init_cords = (random.randint(0,MATRIX_SIZE-n_atoms), random.randint(0,MATRIX_SIZE-n_atoms)) 
    else: 
        init_cords = (0,0)

    if MARGIN == 'black':
        value_r, value_g, value_b=0
    elif MARGIN=='white':
        value_r, value_g, value_b=255
    elif MARGIN=='avg':
        value_r, value_g, value_b = np.mean(r), np.mean(g), np.mean(b)
    
    if MATRIX_SIZE != 0:
        final_r = np.full((MATRIX_SIZE, MATRIX_SIZE), value_r)
        final_g = np.full((MATRIX_SIZE, MATRIX_SIZE), value_g)
        final_b = np.full((MATRIX_SIZE, MATRIX_SIZE), value_b)

        final_r[init_cords[0]:init_cords[0] + n_atoms, init_cords[1]:init_cords[1] + n_atoms] = r
        final_g[init_cords[0]:init_cords[0] + n_atoms, init_cords[1]:init_cords[1] + n_atoms] = g
        final_b[init_cords[0]:init_cords[0] + n_atoms, init_cords[1]:init_cords[1] + n_atoms] = b

        return final_r, final_g, final_b
    return r,g,b

def making_rgb(mat, id, label):
  ''' Function that takes the result of the making_rgb_numerically function and transforms the set of three matrices into a finished png image'''
  combined = np.transpose(np.array((mat[0],mat[1],mat[2])),(1,2,0))

  img = np.array(combined, dtype=np.uint8)

  pImg = Image.fromarray(img, mode='RGB')

  pImg.save(f"{PATH}/{label}/{id}.png")

def process_image(chem, bo, ds, split):

    if DB == 'qm7_demo':
        test_set = qm7_val
    elif DB == 'qm8_demo':
        test_set = qm8_val
    elif DB== 'qm9':
        test_set = qm9_val
    elif DB== 'qm9_2':
        test_set = qm9_2_val
    elif DB== 'qm9_3':
        test_set = qm9_3_val
    elif DB== 'qm9_4':
        test_set = qm9_4_val
    elif DB== 'qm9_6':
        test_set = qm9_6_val
    else:
        test_set = []
    if int(ds.ID.iloc[chem].split('_')[1]) in test_set:
        making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TEST_DIR_NAME)
        print(f"\r{chem} goes to test set", end='')
    else:
        making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TRAIN_DIR_NAME)

def creating_images(start, end, bo, ds, split=0.1, step=1):
    print(f'Creating {end-start+1} images for training model')
    print(f'Rearranging train and test files')
    
    try:
        shutil.rmtree(f'{PATH}/{TRAIN_DIR_NAME}')
        os.makedirs(f'{PATH}/{TRAIN_DIR_NAME}', exist_ok=True)
    except FileNotFoundError:
        os.makedirs(f'{PATH}/{TRAIN_DIR_NAME}', exist_ok=True)

    try:
        shutil.rmtree(f'{PATH}/{TEST_DIR_NAME}')
        os.makedirs(f'{PATH}/{TEST_DIR_NAME}', exist_ok=True)
    except FileNotFoundError:
        os.makedirs(f'{PATH}/{TEST_DIR_NAME}', exist_ok=True)
    
    if SCALING==True:
        step = 30
        global r_range, g_range, b_range
        print(f'Calibration for each spectra (based on {len(ds)/step/len(ds)*100:.2f}% of data):')
        r_range, g_range, b_range = calibration(ds,step,bo)
    
    print(f'Creating images, this process may take a lot of time')
    #partial function
    process_image_partial = partial(process_image, bo=bo, ds=ds, split=split)

    #multiprocessing
    with multiprocessing.Pool() as pool:
        pool.map(process_image_partial, range(start, end+1))

import matplotlib.pyplot as plt

def p(num_epochs, losses, accuracies):
  ''' Function to plot change in loss and accuracy values while training the model '''
  x = range(num_epochs)[2:]

  fig, ax1 = plt.subplots()

  losses = [1/x for x in losses]
  color = 'tab:blue'
  ax1.set_xlabel('Epochs')
  ax1.set_ylabel('loss', color=color)
  ax1.plot(x, losses[2:], color=color)
  ax1.tick_params(axis='y', labelcolor=color)

  ax2 = ax1.twinx()  
  color = 'tab:red'
  ax2.set_ylabel('accuracy', color=color)
  ax2.plot(x, accuracies[2:], color=color)
  ax2.tick_params(axis='y', labelcolor=color)

  plt.title('Loss and accuracy[meV] value')
  plt.show()
