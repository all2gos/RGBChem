import os,sys
import pandas as pd
import numpy as np
import multiprocessing
from functools import partial
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from scripts.matrix_function import *
from PIL import Image
import random
from pathlib import Path
from scripts.params import *
from scripts.reax_ff_data import bo


#does not work well, in effect making_df does not work well either

def get_list_of_files():
    '''Get the list of all .xyz file available, if directory is empty then exctract information from .tar file'''
    try:
        files = os.listdir(f'{PATH}/data')
    except FileNotFoundError:
        os.system('mkdir data')
        os.system(f'tar -xvf dsgdb9nsd.xyz.tar.bz2 -C {PATH}/data')
        files = os.listdir(f'{PATH}/data')
    
    return files


def scale_rgb_values(r, g, b, r_range= (0.0, 14.534), g_range= (0.0, 40.81),b_range= (0.0, 2.53)):
    #r = (255 * (r - r_range[0]) / (r_range[1] - r_range[0])).astype(int)
    #g = (255 * (g - g_range[0]) / (g_range[1] - g_range[0])).astype(int)
    #b = (255 * (b - b_range[0]) / (b_range[1] - b_range[0])).astype(int)

    return r, g, b

def calibration(ds, d, bo):

    '''A function that checks whether the matrices generated 
    on the entered settings contain values in the range 0-255
    '''
    data = []
    start = random.randint(0,5) #to avoid too long execution
    for compound in range(start, len(ds), d): #step != 1 to avoid too long execution
        data.append(making_rgb_numerically(compound, bo, ds, scaling=False))
        print(f'\r Calibration: {100*compound/len(ds):.2f}%', end='')

    max_values = []
    min_values = []

    for matrices_group in zip(*data):
      max_group = np.max([np.max(matrix) for matrix in matrices_group])
      min_group = np.min([np.min(matrix) for matrix in matrices_group])
      max_values.append(max_group)
      min_values.append(min_group)

    print("r_range=", (min_values[0], max_values[0]))
    print("g_range=", (min_values[1], max_values[1]))
    print("b_range=", (min_values[2], max_values[2]))

def making_rgb_numerically(row, bo, ds, scaling=SCALING, verbose = False):
    '''function that, based on a single row in the database, creates three 
    MATRIX_SIZExMATRIX_SIZE matrices that contain numerical data generated by 
    various functions contained in the file matrix_function.py'''

    cords = eval(ds.cords.iloc[row])
    n_atoms = ds.n_atoms.iloc[row]
    atom_types = eval(ds.atom_type.iloc[row])

    r = distance(cords, n_atoms)
    r += ionization(atom_types, n_atoms)
    #g = mulliken(eval(ds.mulliken.iloc[row]), n_atoms)
    g = coulomb_matrix(cords, n_atoms, atom_types, diagonal = False)
    #b = (atomic_charge(atom_types, n_atoms))
    b = (bond_order(distance(cords, n_atoms), atom_types, bo))


    #info to LOG_FILE
    with open(LOG_FILE, 'w') as file:
        print('---IMAGE CREATION DETAILS---', file=file)
        print(f'Function distance called with arguments: cords={cords}, n_atoms={n_atoms}', file=file)
        print(f'Resulting r (after distance): {r}', file=file)
        print(f'Function ionization called with arguments: atom_types={atom_types}, n_atoms={n_atoms}', file=file)
        print(f'Resulting r (after ionization): {r}', file=file)
        print(f'Function coulomb_matrix called with arguments: cords={cords}, n_atoms={n_atoms}, atom_types={atom_types}, diagonal=False', file=file)
        print(f'Resulting g: {g}', file=file)
        print(f'Function bond_order called with arguments: distance(cords, n_atoms)={distance(cords, n_atoms)}, atom_types={atom_types}, bo={bo}', file=file)
        print(f'Resulting b: {b}', file=file)

    return scale_rgb_values(r,g,b) if scaling ==True else r,g,b

def making_rgb(mat, id, label):
  ''' Function that takes the result of the making_rgb_numerically function and transforms the set of three matrices into a finished png image'''
  combined = np.transpose(np.array((mat[0][0],mat[0][1],mat[0][2])),(1,2,0))

  img = np.array(combined, dtype=np.uint8)

  pImg = Image.fromarray(img, mode='RGB')

  pImg.save(f"{PATH}/{label}/{id}.png")

def process_image(chem, bo, ds, split):
    if random.randint(1, int(1/split)) == int(1/split):
        making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TEST_DIR_NAME)
        print(f"\r{chem} goes to test set", end='')
    else:
        making_rgb(making_rgb_numerically(chem, bo, ds), ds.ID.iloc[chem], label=TRAIN_DIR_NAME)

def creating_images(start, end, bo, ds, split=0.1, step=1):
    print(f'Creating {end-start+1} images for training model')
    os.makedirs(f'{PATH}/{TRAIN_DIR_NAME}', exist_ok=True)
    os.makedirs(f'{PATH}/{TEST_DIR_NAME}', exist_ok=True)

    #partial function
    process_image_partial = partial(process_image, bo=bo, ds=ds, split=split)

    #multiprocessing
    with multiprocessing.Pool() as pool:
        pool.map(process_image_partial, range(start, end+1, step))

import matplotlib.pyplot as plt

def p(num_epochs, losses, accuracies):
  ''' Function to plot change in loss and accuracy values while training the model '''
  x = range(num_epochs)[2:]

  fig, ax1 = plt.subplots()

  losses = [1/x for x in losses]
  color = 'tab:blue'
  ax1.set_xlabel('Epochs')
  ax1.set_ylabel('loss', color=color)
  ax1.plot(x, losses[2:], color=color)
  ax1.tick_params(axis='y', labelcolor=color)

  ax2 = ax1.twinx()  
  color = 'tab:red'
  ax2.set_ylabel('accuracy', color=color)
  ax2.plot(x, accuracies[2:], color=color)
  ax2.tick_params(axis='y', labelcolor=color)

  plt.title('Loss and accuracy[meV] value')
  plt.show()
